"use strict";
var html = require('common-tags').html;
var PushRoute = (function () {
    function PushRoute() {
        this.parentFolder = 'routes';
        this.publishName = 'push.ts';
        this.name = 'push';
    }
    Object.defineProperty(PushRoute.prototype, "template", {
        get: function () {
            return ((_a = ["\n      // Relution APIs\n      const pushService = require('relution/push.js');\n      import * as Q from 'q';\n\n      /**\n      * module providing direct access to push.\n      *\n      * registers a push target device.\n      *\n      * <p>\n      * The method attempts fetching an existing device using the metadata\n      * information given. This either works by providing a UUID or using\n      * heuristics based on information typically extracted using Cordova device\n      * plugin. The latter approach solves the potential problem when the client\n      * is uninstalled and reinstalled so that device local information is lost.\n      * </p>\n      * <p>\n      * If it finds one, that device is updated. Otherwise a new\n      * device is created and stored in the database.\n      * </p>\n      * @link [RelutionSDK Push APi](https://relution-io.github.io/relution-sdk/modules/_push_push_.html)\n      * @param app express.js application to hook into.\n      */\n\n      export function init(app: any) {\n        app.post('/api/v1/push/registration',\n          /**\n          * register the device on the push Service\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.registerPushDevice(req.body)).then(res.json.bind(res), next).done();\n          }\n        );\n\n        app.post('/api/v1/push',\n          /**\n          * posts push notification(s).\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.postPushNotification(req.body)).then(res.json.bind(res), next).done();\n          }\n        );\n\n        app.get('/api/v1/push/:uuid',\n          /**\n          * gets push notification status.\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.fetchPushNotification(req.params.uuid)).then(res.json.bind(res), next).done();\n          }\n        );\n      }\n    "], _a.raw = ["\n      // Relution APIs\n      const pushService = require('relution/push.js');\n      import * as Q from 'q';\n\n      /**\n      * module providing direct access to push.\n      *\n      * registers a push target device.\n      *\n      * <p>\n      * The method attempts fetching an existing device using the metadata\n      * information given. This either works by providing a UUID or using\n      * heuristics based on information typically extracted using Cordova device\n      * plugin. The latter approach solves the potential problem when the client\n      * is uninstalled and reinstalled so that device local information is lost.\n      * </p>\n      * <p>\n      * If it finds one, that device is updated. Otherwise a new\n      * device is created and stored in the database.\n      * </p>\n      * @link [RelutionSDK Push APi](https://relution-io.github.io/relution-sdk/modules/_push_push_.html)\n      * @param app express.js application to hook into.\n      */\n\n      export function init(app: any) {\n        app.post('/api/v1/push/registration',\n          /**\n          * register the device on the push Service\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.registerPushDevice(req.body)).then(res.json.bind(res), next).done();\n          }\n        );\n\n        app.post('/api/v1/push',\n          /**\n          * posts push notification(s).\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.postPushNotification(req.body)).then(res.json.bind(res), next).done();\n          }\n        );\n\n        app.get('/api/v1/push/:uuid',\n          /**\n          * gets push notification status.\n          *\n          * @param req containing body JSON to pass as input.\n          * @param res result of call is provided as JSON body data.\n          * @param next function to invoke error handling.\n          */\n          function serviceCall(req: any, res: any, next: any) {\n            Q(pushService.fetchPushNotification(req.params.uuid)).then(res.json.bind(res), next).done();\n          }\n        );\n      }\n    "], html(_a)) + '\n');
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    return PushRoute;
}());
exports.PushRoute = PushRoute;
//# sourceMappingURL=PushRoute.js.map