"use strict";
var chalk = require('chalk');
var path = require('path');
var figures = require('figures');
var lodash_1 = require('lodash');
var rxjs_1 = require('@reactivex/rxjs');
var Relution = require('relution-sdk');
var FileApi_1 = require('../../utility/FileApi');
var RxFs_1 = require('../../utility/RxFs');
var Archiver_1 = require('../../utility/Archiver');
var DebugLog_1 = require('../../utility/DebugLog');
var loader = require('cli-loader')();
/**
 * ```bash
 * ┌─────────┬──────────┬──────────┬────────────────────────────────┐
 * │ Options │ Commands │ Param(s) │ Description                    │
 * │         │          │          │                                │
 * │ deploy  │ deploy   │ <$name>  │ deploy your Baas to the server │
 * │ deploy  │ help     │ --       │ List the Deploy Command        │
 * │ deploy  │ back     │ --       │ Exit to Home                   │
 * │         │          │          │                                │
 * └─────────┴──────────┴──────────┴────────────────────────────────┘
 * ```
 * @todo remove zip file after deploy
 */
var Deploy = (function () {
    function Deploy(owner) {
        this.debuglog = DebugLog_1.DebugLog;
        this._promptkey = 'deployserver';
        this._defaultServer = 'default';
        this._archiver = new Archiver_1.Archiver();
        this._fileApi = new FileApi_1.FileApi();
        this.owner = owner;
        this.userRc = owner.userRc;
        this.i18n = owner.i18n;
        this.relutionSDK = owner.relutionSDK;
        this.debuglog = owner.debuglog;
        this.inquirer = owner.inquirer;
    }
    Deploy.prototype._copy = function (org) {
        return JSON.parse(JSON.stringify(org));
    };
    Deploy.prototype._getServers = function () {
        var _this = this;
        this._defaultServer = 'default';
        return this.userRc.streamRc().exhaustMap(function () {
            var prompt = _this._copy(_this.owner._parent.staticCommands.server.crudHelper.serverListPrompt(_this._promptkey, 'list', 'Select a Server'));
            var indexDefault = lodash_1.findIndex(_this.userRc.server, { default: true });
            if (indexDefault > -1) {
                _this._defaultServer += " " + prompt[0].choices[indexDefault];
                prompt[0].choices.splice(indexDefault, 1);
                prompt[0].choices.unshift(_this._defaultServer);
            }
            return prompt;
        });
    };
    /**
     * choose first on which Server the App has to be deployed
     */
    Deploy.prototype.getServerPrompt = function () {
        var _this = this;
        this._defaultServer = 'default';
        return this._getServers().exhaustMap(function (prompt) {
            return rxjs_1.Observable.fromPromise(_this.inquirer.prompt(prompt));
        });
    };
    /**
     * Get the organisation and test if it has defaultRoles. If not raise an error. If an application is generated by a user in a group that has no defaultRoles the application
     * doesn't work as expected.
     */
    Deploy.prototype.checkOrga = function (resp) {
        var orga = Relution.security.getCurrentOrganization('defaultRoles');
        return orga && orga.defaultRoles && orga.defaultRoles.length > 0;
    };
    /**
     * upload the generated zip to the server
     */
    Deploy.prototype.upload = function (archiveresp, env) {
        var _this = this;
        loader.start();
        // data to upload
        var formData = {
            // Pass a simple key-value pair
            name: this._relutionHjson.name,
            uuid: this._relutionHjson.uuid,
            // Pass optional meta-data with an 'options' object with style: {value: DATA, options: OPTIONS}
            // Use case: for some types of streams, you'll need to provide 'file'-related information manually.
            // See the `form-data` README for more information about options: https://github.com/form-data/form-data
            custom_file: {
                value: archiveresp.readStream,
                options: {
                    filename: path.basename(archiveresp.zip),
                    contentType: 'application/zip'
                }
            }
        };
        if (env) {
            // env key/value is present only if an environment was choosen
            formData.env = env;
        }
        // continuously queries deployment status if server supports this
        var deploymentUrl;
        var deploymentCheck = function (response) {
            if (!deploymentUrl) {
                return response;
            }
            var statusCode;
            return Relution.web.get({
                url: deploymentUrl,
                responseCallback: function (resp) {
                    statusCode = resp.statusCode;
                    return resp;
                }
            }).then(function (body) {
                if (statusCode === 202) {
                    // deployment ongoing, repeat request
                    Relution.debug.assert(!body);
                    return deploymentCheck(response);
                }
                return response;
            }, function (error) {
                if (error && error.statusCode === 404) {
                    // relution server does not support deployment status query
                    return response;
                }
                throw error;
            });
        };
        return rxjs_1.Observable.fromPromise(Relution.web.ajax({
            url: 'upload',
            headers: {
                'Accept': 'text/plain'
            },
            method: 'POST',
            formData: formData,
            requestCallback: function (request) {
                request.once('data', function () { return loader.stop(); });
                request.pipe(process.stdout, { 'end': false });
                return request;
            },
            responseCallback: function (response) {
                deploymentUrl = response.headers['X-Relution-Studio-Deployment-Url'.toLowerCase()];
                return response;
            }
        })
            .finally(function () { return loader.start(); })
            .then(deploymentCheck)
            .finally(function () { return loader.stop(); })
            .then(function (result) {
            _this.debuglog.info(_this.i18n.DEPLOY_SUCCESS);
            // be nice and output URL of application
            var url = Relution.web.resolveApp(_this._relutionHjson);
            if (url) {
                _this.debuglog.info(_this.i18n.DEPLOY_APPURL, url);
            }
            return result;
        }, function (error) {
            _this.debuglog.error(new Error(_this.i18n.DEPLOY_FAILED));
            throw error;
        }));
    };
    /**
     * deploy the baas to the server
     */
    Deploy.prototype.publish = function (args) {
        var _this = this;
        var serverArgName = undefined;
        if (args && args[0]) {
            serverArgName = args[0];
        }
        this._fileApi.path = this.projectDir;
        // loginresponse
        var userResp;
        // choosed environment
        var envName = '';
        // choosed Server
        var choosedServer;
        if (!RxFs_1.RxFs.exist(path.join(process.cwd(), 'relution.hjson')) || !RxFs_1.RxFs.exist(path.join(process.cwd(), '.relutionignore'))) {
            return rxjs_1.Observable.throw(new Error(process.cwd() + " is not a valid Relution Project"));
        }
        // load the environments before
        return this.owner._parent.staticCommands.env.envCollection.getEnvironments()
            .map(function () {
            if (args && args[1]) {
                var exists = lodash_1.find(_this.owner._parent.staticCommands.env.envCollection.collection, { name: args[1] });
                if (exists) {
                    envName = exists.name;
                }
                else {
                    _this.debuglog.warn(_this.i18n.DEPLOY_ENV_NOT_EXISTS(args[1]));
                }
            }
        })
            .exhaustMap(function () {
            return _this._fileApi.readHjson(path.join(_this.projectDir, 'relution.hjson'));
        })
            .exhaustMap(function (relutionHjson) {
            _this._relutionHjson = relutionHjson.data;
            if (!serverArgName) {
                return _this.getServerPrompt();
            }
            return _this._getServers().map(function () {
                return { deployserver: serverArgName };
            });
        })
            .filter(function (server) {
            return server.deployserver !== _this.i18n.CANCEL;
        })
            .exhaustMap(function (server) {
            if (server.deployserver.toString().trim() === _this._defaultServer.toString().trim()) {
                choosedServer = lodash_1.find(_this.userRc.server, { default: true });
            }
            else {
                choosedServer = lodash_1.find(_this.userRc.server, { id: server.deployserver });
            }
            loader.start();
            return _this.relutionSDK.login(choosedServer);
        })
            .exhaustMap(function (resp) {
            userResp = resp.user;
            loader.stop();
            if (!_this.checkOrga(userResp)) {
                return rxjs_1.Observable.throw(new Error(_this.i18n.DEPLOY_NO_ORGA));
            }
            _this.debuglog.info(chalk.green("Login as " + (userResp.givenName ? userResp.givenName + ' ' + userResp.surname : userResp.name) + " succeeded. " + figures.tick));
            // console.log(this.owner._parent.staticCommands.env.chooseEnv);
            if (_this.owner._parent.staticCommands.env.envCollection.collection.length > 0 && !envName || !envName.length) {
                // must choose an environment
                return _this.owner._parent.staticCommands.env.chooseEnv.choose('list')
                    .filter(function (answers) {
                    return answers.env !== _this.i18n.CANCEL;
                })
                    .map(function (answers) {
                    envName = answers[_this.owner._parent.staticCommands.env.chooseEnv.promptName];
                    return _this._archiver.createBundle();
                });
            }
            else {
                // there is no environment present
                return rxjs_1.Observable.of(_this._archiver.createBundle());
            }
        })
            .exhaustMap(function (log) {
            return log.map(function (respLog) {
                if (respLog.file || respLog.directory) {
                    _this.debuglog.info(chalk.magenta(respLog.file ? "add file " + respLog.file : "add directory " + respLog.directory));
                }
                else if (respLog.processed) {
                    _this.debuglog.info(chalk.green(respLog.processed) + ' ' + figures.tick);
                }
                return respLog;
            })
                .filter(function (respLog) {
                return respLog['zip'];
            });
        })
            .exhaustMap(function (respLog) {
            _this.debuglog.info(chalk.green(respLog.message) + ' ' + figures.tick);
            return _this.upload(respLog, envName);
        })
            .ignoreElements() // log piped already
            .finally(function () {
            loader.stop();
        }).do({
            error: function () {
                // is directly used
                if (args && args[0] && args[1]) {
                    process.exit(-1);
                }
            },
            complete: function () {
                // is directly used
                if (args && args[0] && args[1]) {
                    process.exit(0);
                }
            }
        });
    };
    Object.defineProperty(Deploy.prototype, "projectDir", {
        get: function () {
            if (!this._projectDir) {
                this._projectDir = process.cwd();
            }
            return this._projectDir;
        },
        set: function (v) {
            this._projectDir = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Deploy.prototype, "relutionHjson", {
        get: function () {
            return this._relutionHjson;
        },
        set: function (v) {
            this._relutionHjson = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Deploy.prototype, "defaultServer", {
        get: function () {
            return this._defaultServer;
        },
        enumerable: true,
        configurable: true
    });
    return Deploy;
}());
exports.Deploy = Deploy;
//# sourceMappingURL=Deploy.js.map