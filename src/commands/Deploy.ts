import {Command} from './../utility/Command';
import * as chalk from 'chalk';
import {find, findIndex, sortBy} from 'lodash';
import {Observable} from '@reactivex/rxjs';
import {ServerModelRc, ServerModel} from './../models/ServerModelRc';
import * as Relution from 'relution-sdk';
import {Archiver} from './../utility/Archiver';
const figures = require('figures');

const STUDIO:string = 'studio';
/**
 * create a new Baas for the Developer
 */
export class Deploy extends Command {
  constructor() {
    super('deploy');
  }
  private _deployServer: ServerModel;
  private _promptkey: string = 'deployserver';
  private _defaultServer: string = 'default';
  private _archiver: Archiver = new Archiver();

  public commands: any = {
    deploy: {
      description: this.i18n.DEPLOY,
      vars: {
        name: {
          pos: 0
        }
      }
    },
    help: {
      description: this.i18n.LIST_COMMAND('Deploy')
    },
    quit: {
      description: this.i18n.EXIT_TO_HOME
    }
  };

  loginRelution(choosedServer: ServerModelRc) {
    Relution.init({
      serverUrl: choosedServer.serverUrl,
      application: STUDIO
    });

    //console.log('Relution', JSON.stringify(Relution.security, null, 2))
    let credentials = {
      userName: choosedServer.userName,
      password: choosedServer.password
    };

    return Observable.fromPromise(Relution.web.login(credentials));
  }
  /**
   * choose first on which Server the App has to be deployed
   */
  getServerPrompt(): Observable<any> {
    let prompt = this._parent.staticCommands.server.crudHelper.serverListPrompt(this._promptkey, 'list', 'Select a Server');
    let indexDefault: number = findIndex(this.userRc.config.server, { default: true });
    if (indexDefault > -1) {
      this._defaultServer += ` ${prompt[0].choices[indexDefault]}`
      prompt[0].choices.splice(indexDefault, 1);
      prompt[0].choices.unshift(this._defaultServer);
    }
    return Observable.fromPromise(this.inquirer.prompt(prompt));
  }

  /**
   * Get the organisation and test if it has defaultRoles. If not raise an error. If an application is generated by a user in a group that has no defaultRoles the application
   * doesn't work as expected.
   */
  checkOrga(resp: any) {
    return resp.organization.defaultRoles.length > 0;
  }

  upload():Observable<any>{

    return Observable.create((observer:any) => {
      observer.complete();
      //Relution.
    });

  }
  /**
   * deploy the baas to the server
   */
  public deploy(): Observable<any> {
    //loginresponse
    let resp: any = null;
    //choosed environment
    let envName: string = '';
    //choosed Server
    let choosedServer:any;

    return Observable.create(
      (observer: any) => {
        /**
         * please choose a server
         */
        this.getServerPrompt().subscribe(
          (answers: any) => {
            choosedServer = answers[this._promptkey];
            /**
             * Take me out of here
             */
            if (choosedServer === this.i18n.TAKE_ME_OUT) {
              return observer.complete();
            }
            /**
             * get default server
             */
            if (choosedServer === this._defaultServer) {
              console.log(this.userRc.config.server);
              choosedServer = find(this.userRc.config.server, { default: true });
            }

            /**
             * login on server
             */
            this.loginRelution(choosedServer).subscribe(
              (answer: any) => {
                resp = answer;
                //user is wrong
                if (!this.checkOrga(resp)) {
                  console.error(chalk.red(`Organization has no defaultRoles. This will cause problems creating applications. Operation not permitted.`));
                  return observer.complete();
                }


                /**
                 * get environment
                 */
                this._parent.staticCommands.env.chooseEnv.choose('list').subscribe(
                  (answers: any) => {
                    envName = answers[this._parent.staticCommands.env.chooseEnv.promptName];
                    if (envName === this.i18n.TAKE_ME_OUT) {
                      return observer.complete();
                    }
                  },
                  (e: Error) => {

                  },
                  () => {
                    //create a zip and get stream
                    this._archiver.createBundle().subscribe(
                      (log: any) => {
                        if (log.file || log.directory) {
                          console.log(chalk.magenta(log.file ? `add file ${log.file}` : `add directory ${log.directory}`));
                        } else if (log.zip) {
                          /**
                           * {
                           *  zip: path:string,
                           *  message: string,
                           *  readStream: stream
                           * }
                           */
                          console.log(chalk.green(log.message) + ' ' + figures.tick);
                          //console.log(log.readStream);
                        } else if (log.processed) {
                          console.log(chalk.green(log.processed) + ' ' + figures.tick);
                        }
                      }
                    );
                  }
                );
                console.log(`logged in as ${resp.user.givenName ? resp.user.givenName + ' ' + resp.user.surname : resp.user.name}`);
              },
              (e: Error) => {
                console.error(e.message, e.stack);
                observer.error(e);
              },
              () => {
                console.log('done');
              }
            );
          }
        )
      }
    );
  }
}
